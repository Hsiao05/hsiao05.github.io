<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä»Šå¤©çœ‹ä»€ä¹ˆåŠ¨ç”»ï¼Ÿ</title>
    <style>
        :root {
            /* æ¸…æ–°æ—¥ç³»é…è‰² */
            --primary: #ff9a9e;          /* æ¨±èŠ±ç²‰ */
            --primary-hover: #ff758c;
            --accent: #a18cd1;           /* è–°è¡£è‰ç´« */
            --glass: rgba(255, 255, 255, 0.85);
            --shadow: 0 10px 30px rgba(255, 154, 158, 0.15);
            --text-main: #4a4a4a;
            --text-sub: #888;
            
            /* è½¬ç›˜é©¬å¡é¾™é…è‰²æ±  */
            --c1: #FFB7B2; --c2: #B5EAD7; --c3: #E2F0CB; --c4: #C7CEEA; --c5: #FFDAC1;
        }

        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            font-family: "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
            background-image: linear-gradient(to top, #fbc2eb 0%, #a6c1ee 100%);
            background-attachment: fixed;
            min-height: 100vh;
            color: var(--text-main);
            overflow-x: hidden;
            position: relative;
        }

        /* æ¨±èŠ±èƒŒæ™¯ç”»å¸ƒ */
        #sakuraCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1100px;
            width: 95%;
            margin: 40px auto;
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 40px;
            align-items: start;
        }

        /* å·¦ä¾§ï¼šè½¬ç›˜åŒºåŸŸ */
        .wheel-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--glass);
            backdrop-filter: blur(15px);
            border-radius: 30px;
            padding: 30px;
            box-shadow: var(--shadow);
            border: 2px solid rgba(255, 255, 255, 0.6);
            position: sticky;
            top: 20px;
        }

        .wheel-wrapper {
            position: relative;
            width: 380px;
            height: 380px;
            margin-bottom: 25px;
            border-radius: 50%;
            padding: 10px;
            background: white;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
        }

        canvas#wheelCanvas {
            width: 100%; height: 100%;
            border-radius: 50%;
            transition: transform 0.1s;
        }

        .pointer {
            position: absolute;
            top: -15px; left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
        }
        .pointer::after {
            content: ''; display: block;
            width: 40px; height: 50px;
            clip-path: polygon(50% 100%, 0 0, 100% 0);
            background: linear-gradient(to bottom, #ff758c, #ff7eb3);
        }

        .spin-btn {
            background: linear-gradient(135deg, var(--primary) 0%, #f78ca0 100%);
            border: none;
            padding: 16px 60px;
            border-radius: 50px;
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 20px rgba(255, 117, 140, 0.3);
        }
        .spin-btn:hover { transform: translateY(-3px) scale(1.02); }
        .spin-btn:disabled { background: #e0e0e0; color: #999; cursor: not-allowed; transform: none; box-shadow: none;}

        /* å³ä¾§ï¼šåˆ—è¡¨åŒºåŸŸ */
        .control-section {
            background: var(--glass);
            border-radius: 30px;
            padding: 30px;
            box-shadow: var(--shadow);
            border: 2px solid rgba(255, 255, 255, 0.6);
            min-height: 500px;
        }

        h1 { margin: 0 0 20px 0; color: var(--text-main); font-size: 1.6rem; display: flex; align-items: center; }
        h1::before { content: 'ğŸŒ¸'; margin-right: 10px; }

        /* æœç´¢æ¡†ç¾åŒ– */
        .search-box { position: relative; margin-bottom: 25px; }
        .search-input {
            width: 100%; padding: 18px 25px;
            border: 2px solid transparent;
            background: #f0f2f5;
            border-radius: 20px;
            font-size: 1rem; color: #555;
            transition: all 0.3s;
        }
        .search-input:focus { background: white; border-color: var(--primary); }

        .search-results {
            position: absolute; top: 110%; left: 0; width: 100%;
            background: white; border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            max-height: 350px; overflow-y: auto;
            z-index: 100; display: none; padding: 10px;
        }

        .result-item {
            display: flex; align-items: center;
            padding: 10px; cursor: pointer;
            border-radius: 10px; transition: background 0.2s;
        }
        .result-item:hover { background: #fff0f3; }
        .result-item img {
            width: 45px; height: 45px; object-fit: cover;
            border-radius: 8px; margin-right: 15px;
        }

        /* æ·±åº¦æœç´¢æŒ‰é’® */
        .deep-search-btn {
            display: flex; align-items: center; justify-content: center;
            padding: 15px; margin-top: 5px;
            background: #f8f9fa; border-radius: 10px;
            cursor: pointer; color: var(--accent);
            font-weight: bold; font-size: 0.95rem;
            transition: 0.2s; border: 1px dashed #d1d1d1;
        }
        .deep-search-btn:hover { background: #f3e5f5; border-color: var(--accent); }

        .header-row {
            display: flex; justify-content: space-between; align-items: baseline;
            margin-bottom: 15px; color: var(--text-sub); font-size: 0.9rem;
        }
        .clear-btn {
            color: #ff758c; background: rgba(255, 117, 140, 0.1);
            border: none; padding: 5px 15px; border-radius: 15px;
            cursor: pointer; transition: 0.2s;
        }
        .clear-btn:hover { background: rgba(255, 117, 140, 0.2); }

        .anime-list {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 20px;
        }
        .anime-card {
            position: relative; background: white;
            border-radius: 12px; padding: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            transition: transform 0.25s; cursor: pointer;
        }
        .anime-card:hover { transform: translateY(-5px); }
        .anime-card img {
            width: 100%; aspect-ratio: 2/3; object-fit: cover;
            border-radius: 8px; display: block;
        }
        .anime-card .remove-btn {
            position: absolute; top: -5px; right: -5px;
            background: white; color: #ff758c;
            width: 24px; height: 24px; border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center;
            opacity: 0; transform: scale(0.8); transition: all 0.2s;
        }
        .anime-card:hover .remove-btn { opacity: 1; transform: scale(1); }
        .anime-card p {
            font-size: 0.85rem; margin: 8px 0 0; color: #555;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: center;
        }

        /* å¼¹çª— */
        .winner-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000; opacity: 0; pointer-events: none; transition: opacity 0.4s;
        }
        .winner-modal.show { opacity: 1; pointer-events: auto; }
        .winner-content {
            background: white; padding: 40px; border-radius: 30px;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            transform: translateY(20px); transition: transform 0.4s;
            max-width: 90%; width: 380px; border: 4px solid #fff0f3;
        }
        .winner-modal.show .winner-content { transform: translateY(0); }
        .winner-img {
            width: 180px; height: 260px; object-fit: cover;
            border-radius: 15px; margin: 20px 0; border: 4px solid white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .close-modal {
            background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%);
            color: white; border: none; padding: 12px 40px; border-radius: 25px;
            cursor: pointer; font-size: 1rem; font-weight: bold;
            box-shadow: 0 8px 15px rgba(161, 140, 209, 0.3); transition: transform 0.2s;
        }
        .close-modal:hover { transform: scale(1.05); }

        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            .wheel-wrapper { width: 300px; height: 300px; }
        }
    </style>
</head>
<body>

<canvas id="sakuraCanvas"></canvas>

<div class="container">
    <div class="wheel-section">
        <div class="wheel-wrapper">
            <div class="pointer"></div>
            <canvas id="wheelCanvas" width="800" height="800"></canvas>
        </div>
        <button class="spin-btn" id="spinBtn" onclick="spin()">éšæœºé€‰æ‹©</button>
    </div>

    <div class="control-section">
        <h1>æ·»åŠ æƒ³çœ‹çš„åŠ¨ç”»</h1>
        
        <div class="search-box">
            <input type="text" class="search-input" id="searchInput" placeholder="æœç´¢åŠ¨ç”»..." autocomplete="off">
            <div class="search-results" id="searchResults"></div>
        </div>

        <div class="header-row">
            <span>å€™é€‰åˆ—è¡¨ (<span id="count">0</span>)</span>
            <button class="clear-btn" onclick="clearAll()">æ¸…ç©º</button>
        </div>

        <div class="anime-list" id="animeList"></div>
    </div>
</div>

<div class="winner-modal" id="winnerModal">
    <div class="winner-content">
        <h2 style="color: #ff758c; margin:0; font-size:1.2rem;">âœ¨ é€‰åˆ°äº†ğŸ‘‡ âœ¨</h2>
        <img src="" alt="" class="winner-img" id="winnerImg">
        <h3 class="winner-title" id="winnerTitle">åŠ¨ç”»åç§°</h3>
        <button class="close-modal" onclick="closeModal()">å°±å†³å®šæ˜¯ä½ äº†</button>
    </div>
</div>

<script>
    /* ================= æ¨±èŠ±ç‰¹æ•ˆ ================= */
    class SakuraEngine {
        constructor() {
            this.canvas = document.getElementById('sakuraCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.resize();
            this.petals = [];
            window.addEventListener('resize', () => this.resize());
            const count = window.innerWidth > 800 ? 50 : 20;
            for(let i=0; i<count; i++) this.addPetal();
            this.animate();
        }
        resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
        addPetal() {
            this.petals.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height - this.canvas.height,
                size: Math.random() * 15 + 8,
                speed: Math.random() * 1.5 + 0.5,
                sway: Math.random() * 2 - 1, swaySpeed: Math.random() * 0.02 + 0.005,
                angle: Math.random() * Math.PI * 2, spin: Math.random() * 0.02 - 0.01,
                color: `rgba(255, ${150 + Math.random()*50}, ${180 + Math.random()*30}, ${Math.random()*0.3 + 0.4})`
            });
        }
        drawPetal(p) {
            this.ctx.save(); this.ctx.translate(p.x, p.y); this.ctx.rotate(p.angle);
            this.ctx.fillStyle = p.color; this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.bezierCurveTo(p.size/2, -p.size/2, p.size, -p.size/2, p.size, 0);
            this.ctx.bezierCurveTo(p.size, p.size/2, p.size/2, p.size/2, 0, 0);
            this.ctx.fill(); this.ctx.restore();
        }
        animate() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.petals.forEach(p => {
                p.y += p.speed; p.x += Math.sin(p.y * p.swaySpeed) * p.sway; p.angle += p.spin;
                if (p.y > this.canvas.height) { p.y = -20; p.x = Math.random() * this.canvas.width; }
                this.drawPetal(p);
            });
            requestAnimationFrame(() => this.animate());
        }
    }
    new SakuraEngine();

    /* ================= ä¸šåŠ¡é€»è¾‘ ================= */
    const API_URL = 'https://lab.magiconch.com/api/bangumi/';
    const IMAGE_URL = 'https://api.anitabi.cn/bgm/anime/';
    const PASTEL_COLORS = ['#FFB7B2', '#B5EAD7', '#E2F0CB', '#C7CEEA', '#FFDAC1'];

    let items = [
        { id: 10380, title: "å‘½è¿çŸ³ä¹‹é—¨" },
        { id: 876, title: "CLANNAD" },
        { id: 27364, title: "å†°è“" }
    ];

    const canvas = document.getElementById('wheelCanvas');
    const ctx = canvas.getContext('2d');
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');
    const animeListEl = document.getElementById('animeList');
    const spinBtn = document.getElementById('spinBtn');
    
    let isSpinning = false;
    let currentRotation = 0; 
    let spinVelocity = 0; 

    init();

    function init() {
        renderList();
        drawWheel();
        
        let timeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(timeout);
            const keyword = e.target.value.trim();
            if (!keyword) {
                searchResults.style.display = 'none';
                return;
            }
            // é»˜è®¤å…ˆè¿›è¡Œå¿«é€Ÿæœç´¢
            timeout = setTimeout(() => searchAnime(keyword), 500);
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-box')) {
                searchResults.style.display = 'none';
            }
        });
    }

    // æ¸²æŸ“æœç´¢ç»“æœåˆ—è¡¨
    function renderSearchResults(data, keyword) {
        searchResults.innerHTML = '';
        
        // 1. æ¸²æŸ“æ™®é€šç»“æœ
        if (data && data.length > 0) {
            data.slice(0, 8).forEach(anime => {
                const div = document.createElement('div');
                div.className = 'result-item';
                div.innerHTML = `
                    <img src="${IMAGE_URL}${anime.id}/cover.jpg" crossorigin="anonymous">
                    <span>${anime.title}</span>
                `;
                div.onclick = () => addItem(anime);
                searchResults.appendChild(div);
            });
        } else {
            searchResults.innerHTML = `<div style="padding:15px; text-align:center; color:#999; font-size:0.9rem;">æš‚æ— æœ¬åœ°ç»“æœï¼Œè¯•è¯•å…¨ç«™æœç´¢</div>`;
        }

        // 2. åº•éƒ¨æ·»åŠ â€œæ·±åº¦æœç´¢â€æŒ‰é’®
        const deepSearchDiv = document.createElement('div');
        deepSearchDiv.className = 'deep-search-btn';
        deepSearchDiv.innerHTML = `ğŸŒ åœ¨â€œç•ªç»„è®¡åˆ’â€å…¨ç«™æœç´¢ "${keyword}"`;
        deepSearchDiv.onclick = () => searchOnline(keyword);
        searchResults.appendChild(deepSearchDiv);

        searchResults.style.display = 'block';
    }

    // é»˜è®¤å¿«é€Ÿæœç´¢ (Cache/Hot)
    async function searchAnime(keyword) {
        try {
            const res = await fetch(`${API_URL}animes?keyword=${encodeURIComponent(keyword)}`);
            const data = await res.json();
            renderSearchResults(data, keyword);
        } catch (err) {
            console.error(err);
        }
    }

    // å…¨ç«™æœç´¢ (Realtime Bangumi Search)
    async function searchOnline(keyword) {
        const btn = document.querySelector('.deep-search-btn');
        if(btn) btn.innerText = "â³ æ­£åœ¨è¿æ¥ç•ªç»„è®¡åˆ’æ•°æ®åº“...";
        
        try {
            // ä½¿ç”¨ anime/onlines æ¥å£
            const res = await fetch(`${API_URL}anime/onlines?keyword=${encodeURIComponent(keyword)}`);
            const data = await res.json();
            
            // é‡æ–°æ¸²æŸ“ç»“æœï¼Œè¿™æ¬¡ä¸å¸¦â€œæ·±åº¦æœç´¢â€æŒ‰é’®äº†ï¼Œæˆ–è€…æç¤ºå·²æ˜¯å…¨ç«™ç»“æœ
            searchResults.innerHTML = '';
            if (data.length === 0) {
                searchResults.innerHTML = '<div style="padding:15px; text-align:center; color:#999">å…¨ç«™ä¹Ÿæ²¡æœåˆ°ï¼Œæ¢ä¸ªå…³é”®è¯ï¼Ÿ</div>';
            } else {
                data.forEach(anime => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `
                        <img src="${IMAGE_URL}${anime.id}/cover.jpg" crossorigin="anonymous">
                        <span>${anime.title}</span>
                    `;
                    div.onclick = () => addItem(anime);
                    searchResults.appendChild(div);
                });
                const tips = document.createElement('div');
                tips.style.padding = "10px";
                tips.style.textAlign = "center";
                tips.style.fontSize = "0.8rem";
                tips.style.color = "#aaa";
                tips.innerText = "--- å·²æ˜¾ç¤ºå…¨ç«™æœç´¢ç»“æœ ---";
                searchResults.appendChild(tips);
            }
        } catch (err) {
            if(btn) btn.innerText = "âŒ è¿æ¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•";
            console.error(err);
        }
    }

    function addItem(anime) {
        if (items.some(i => i.id === anime.id)) {
            alert('å·²ç»åœ¨åˆ—è¡¨é‡Œå•¦ï¼');
            searchResults.style.display = 'none';
            searchInput.value = '';
            return;
        }
        items.push(anime);
        searchInput.value = '';
        searchResults.style.display = 'none';
        renderList();
        drawWheel();
    }

    function removeItem(id) {
        if (isSpinning) return;
        items = items.filter(i => i.id !== id);
        renderList();
        drawWheel();
    }

    function clearAll() {
        if (isSpinning) return;
        if(confirm('ç¡®å®šæ¸…ç©ºåˆ—è¡¨å—ï¼Ÿ')){
            items = [];
            renderList();
            drawWheel();
        }
    }

    function renderList() {
        document.getElementById('count').innerText = items.length;
        animeListEl.innerHTML = items.map(item => `
            <div class="anime-card" onclick="flashHighlight(${item.id})">
                <div class="remove-btn" onclick="event.stopPropagation(); removeItem(${item.id})">Ã—</div>
                <img src="${IMAGE_URL}${item.id}/cover.jpg" crossorigin="anonymous" loading="lazy">
                <p>${item.title}</p>
            </div>
        `).join('');
    }

    function drawWheel() {
        const width = canvas.width;
        const height = canvas.height;
        const cx = width / 2;
        const cy = height / 2;
        const radius = width / 2 - 20;
        
        ctx.clearRect(0, 0, width, height);

        if (items.length === 0) {
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#f0f2f5';
            ctx.fill();
            ctx.fillStyle = '#ccc';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("è¯·æ·»åŠ åŠ¨ç”»", cx, cy);
            return;
        }

        const sliceAngle = (Math.PI * 2) / items.length;

        items.forEach((item, index) => {
            const startAngle = index * sliceAngle + currentRotation;
            const endAngle = startAngle + sliceAngle;

            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, startAngle, endAngle);
            ctx.closePath();

            ctx.fillStyle = PASTEL_COLORS[index % PASTEL_COLORS.length];
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#fff';
            ctx.stroke();

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(startAngle + sliceAngle / 2);
            ctx.textAlign = "right";
            ctx.fillStyle = "#555";
            ctx.font = "bold 28px sans-serif";
            let text = item.title;
            if(text.length > 8) text = text.substring(0,8) + '..';
            ctx.fillText(text, radius - 40, 10);
            ctx.restore();
        });

        ctx.beginPath();
        ctx.arc(cx, cy, 60, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸŒ¸', cx, cy + 5);
    }

    function spin() {
        if (items.length < 2) {
            alert("è‡³å°‘æ·»åŠ ä¸¤ä¸ªåŠ¨ç”»æ‰èƒ½å¼€å§‹å“¦ï¼");
            return;
        }
        if (isSpinning) return;

        isSpinning = true;
        spinBtn.disabled = true;
        spinBtn.innerText = "æ—‹è½¬ä¸­...";
        spinVelocity = 0.4 + Math.random() * 0.2; 
        requestAnimationFrame(animateSpin);
    }

    function animateSpin() {
        spinVelocity *= 0.99; 
        currentRotation += spinVelocity;
        if (currentRotation >= Math.PI * 2) currentRotation -= Math.PI * 2;
        drawWheel();

        if (spinVelocity > 0.001) {
            requestAnimationFrame(animateSpin);
        } else {
            isSpinning = false;
            spinBtn.disabled = false;
            spinBtn.innerText = "ğŸŒ¸ å†è¯•ä¸€æ¬¡ ğŸŒ¸";
            determineWinner();
        }
    }

    function determineWinner() {
        const sliceAngle = (Math.PI * 2) / items.length;
        let effectiveAngle = (Math.PI * 1.5 - currentRotation) % (Math.PI * 2);
        if (effectiveAngle < 0) effectiveAngle += Math.PI * 2;
        const winningIndex = Math.floor(effectiveAngle / sliceAngle);
        showWinner(items[winningIndex]);
    }

    function showWinner(anime) {
        const modal = document.getElementById('winnerModal');
        document.getElementById('winnerImg').src = `${IMAGE_URL}${anime.id}/cover.jpg`;
        document.getElementById('winnerTitle').innerText = anime.title;
        modal.classList.add('show');
    }

    function closeModal() {
        document.getElementById('winnerModal').classList.remove('show');
    }
    function flashHighlight(id) {}
</script>
</body>
</html>
